# 双机调试
	- 主机需要去设置 物理COM口的传输率为 115200
	- windbg中,使用   \\.\pipe\com_1

# kword{
	VPB 	Volume Parameter Block 
}

# 问题{
	- 同一个driver 可以有多个device?  一个网卡驱动程序,同时挂了2个物理网卡

	- 扩展build, 在其结束之后, 把生成的文件拷贝到制定目录
		需要学习如何扩展微软的nmake 
		新增,编译成功后 自动copy的事宜, 不动手,许多东西都白做
	- 通过nmake 把编译生成的文件自动送到共享folder里面
}

# ddk{
		- build会调用nmake工具去解析makefile,进行编译
		- 使用build 进行构建
			E:\>set | findstr /i NTMAKEENV
				NTMAKEENV=C:\WinDDK\7600.16385.1\bin

}

# Log{
	# 第一个蓝屏, 2020/12/25{
	  系统线程异常未处理
	}
}

# API{
	//
	swprintf
	//
	KdPrint, 
	//
	IoCreateDevice
	IoDeleteDevice
	IoCreateSymbolicLink		// sym-name <--> dev_name
	IoDeleteSymbolicLink

	IoGetAttachedDevice
}

# 标识符号链接字符串{
	- kernel  	\??\
	- user 		\\.\
}


# Device {
	# I/O database ( create the device into IO_DB)
	# IoCreateDevice {
		# 参数，独占 {
			-1 ，InitializeObjectAttributes
			-2 ，objectAttributes.Attributes |= OBJ_EXCLUSIVE;
		}
		# 对象管理器的参与 {
			- ObCreateObject（KernelMode，IoDeviceObjectType，Device_Size,）
			- 通过上步，创建除了内存			
		}
		# {

		}
	}
}


# IRQL{
	# {
		KIRQL irql;
		irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
		//
		KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
	}
}

# IRP {
	
	# based on Packet-driven{
		header (fixed part)  			: IRP
		body (in each driver layer)		: IO_STACK_LOCATION
	}

	# PIO_STACK_LOCATION {
		和其关系紧密相连
		os或者驱动创建IRP的同时，就会创建与之相关联的IO_STACK_LOCATON
	}
	# {
		CurrentLocation
		StackCount
	}

	# 转发{
		pdx->NextStackDevice = IoAttachDeviceToDeviceStack(fdo, PhysicalDeviceObject);
		IoCallDriver(pdx->NextStackDevice, Irp);
	}

	# MasterIrp & AssociatedIrp {
		if (Irp->Flags & IRP_ASSOCIATED_IRP)
		{
			masterIrp = Irp->AssociatedIrp.MasterIrp;
		}
	
	}



	#{
		Irp->CurrentLocation <= (CCHAR) (Irp->StackCount + 1);
	} 

	# IoGetCurrentIrpStackLocation {	return Irp->Tail.Overlay.CurrentStackLocation;	}

	# IoMarkIrpPending( Irp )  {IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED} 
}


# IO操作常见套路（可以写本书）{
	
}

# 异步IO{
	# 责任委托
	# 注册完成历程，
}

# 通信 {
	CreateFile + DeviceIoControl
}